#pragma kernel ApplyAndPredict
#pragma kernel UpdateSpatialHash
#pragma kernel Reorder
#pragma kernel ReorderCopyBack 

#pragma kernel CalcLagrangeOperator
#pragma kernel CalcDeltaPosition
#pragma kernel UpdatePredictPosition
#pragma kernel UpdateProperty           
#pragma kernel VorticityAndViscosity    

#include "./PBF3D.hlsl"

static const int ThreadGroupSize = 256;

// todo: Refactor the compute shaer file and updateSettings func in main script.
// todo: Rename the PBF3D.hlsl and pass the constant value in update setting.       // finish and check again
// todo: make sure the radius check of neighbor search is correct.                  // check
// todo: buffer for kernel not bind yet.        
// todo: buffer which new set is not init yet. 
// todo: interaction 3d, gravity point and fluid planet
// todo: change the while loop to for loop.

[numthreads(ThreadGroupSize, 1, 1)]
void ApplyAndPredict(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
    
    float3 currV = Velocities[id.x] + deltaTime * float3(0, gravity, 0);
    
    float3 pPos = Positions[id.x] + deltaTime * currV;        
    ResolveCollisions(pPos ,currV, collisionDamping);        
    
    PredictedPositions[id.x] = pPos;
    Velocities[id.x] = currV;
          
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    uint index = id.x;
    int3 cell = GetCell3D(PredictedPositions[index], smoothingRadius);
    uint hash = HashCell3D(cell);
    uint key = KeyFromHash(hash, numParticles);
    
    SpatialKeys[id.x] = key;
}

[numthreads(ThreadGroupSize, 1, 1)]
void Reorder(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    uint sortedIndex = SortedIndices[id.x];
    SortTarget_Positions[id.x] = Positions[sortedIndex];
    SortTarget_PredictedPositions[id.x] = PredictedPositions[sortedIndex];
    SortTarget_Velocities[id.x] = Velocities[sortedIndex];
}

[numthreads(ThreadGroupSize, 1, 1)]
void ReorderCopyBack(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    Positions[id.x] = SortTarget_Positions[id.x];
    PredictedPositions[id.x] = SortTarget_PredictedPositions[id.x];
    Velocities[id.x] = SortTarget_Velocities[id.x];
}

[numthreads(ThreadGroupSize, 1, 1)]
void CalcLagrangeOperator(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;

    float3 currPos = PredictedPositions[id.x];
    float density = 0;
    
    int3 originCell = GetCell3D(currPos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;

    float3 grad_i = float3(0.0f, 0.0f, 0.0f);
    float grad_j = 0;
    
    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];       // start index?

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex ++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            if (neighbourKey != key) break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 dir2Neighbour = neighbourPos - currPos;
            float sqrDstToNeighbour = dot(dir2Neighbour, dir2Neighbour);
            float dstToNeighbour = length(dir2Neighbour);
            
            if (sqrDstToNeighbour > sqrRadius) continue;       
            
            // calc
            density += WPoly6(dir2Neighbour, smoothingRadius);
            float3 currGrad = WSpikyGrad(dir2Neighbour, smoothingRadius);
            currGrad = currGrad * inv_rho0;           
            grad_i += currGrad;
            if (neighbourIndex != id.x)
            {
                grad_j += dot(currGrad, currGrad);
            }
        }
    }

    float gradSum = grad_j + dot(grad_i, grad_i);
    float constraint = max(density * inv_rho0 - 1.0f, 0.0f);
    float lambda = -constraint / (gradSum + lambdaEps);
    
    Densities[id.x] = density;
    LOperator[id.x] = lambda;
}

[numthreads(ThreadGroupSize, 1, 1)]
void CalcDeltaPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;

    float currPos = PredictedPositions[id.x];
    int3 originCell = GetCell3D(currPos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    
    float lambda_i = LOperator[id.x];
    float WDeltaQ = WPoly6(float3(DeltaQ, 0.0f, 0.0f), smoothingRadius);
    // float WDeltaQ = SmoothingKernelPoly6(DeltaQ, smoothingRadius);
    float3 _deltaPos = float3(0.0f, 0.0f, 0.0f);
    
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];
        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex ++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            float3 neighbourPos = PredictedPositions[neighbourIndex];
            
            if (neighbourKey != key) break;

            float3 dir2Neighbour = neighbourPos - currPos;
            float sqrDstToNeighbour = dot(dir2Neighbour, dir2Neighbour);
            float dstToNeighbour = length(dir2Neighbour);
            
            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // calc
            float poly6 = WPoly6(dir2Neighbour, smoothingRadius);
            // float S_corr = -S_corr_K * pow(abs(poly6 / WDeltaQ), S_corr_N);
            float S_corr = -S_corr_K * pow(abs(poly6 / WDeltaQ), S_corr_N);
            float lambda_j = LOperator[neighbourIndex];
            float lambdaSum = lambda_i + lambda_j + S_corr;
            float3 currGrad = WSpikyGrad(dir2Neighbour, smoothingRadius);
            _deltaPos += lambdaSum * currGrad;      //
        }
    }
    _deltaPos = _deltaPos * inv_rho0;
    DeltaPos[id.x] = _deltaPos;
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdatePredictPosition(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
    float3 pPos = PredictedPositions[id.x];
    float3 dPos = DeltaPos[id.x];
    PredictedPositions[id.x] = pPos + dPos;
    
    // float3 pPos = PredictedPositions[id.x] + DeltaPos[id.x];
    // float3 currVel = pPos/deltaTime;
    // ResolveCollisions(pPos, currVel, collisionDamping);
    // PredictedPositions[id.x] = pPos;
}

[numthreads(ThreadGroupSize, 1, 1)]
void UpdateProperty(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
    
    float3 currPos = Positions[id.x];
    float3 currPrePos = PredictedPositions[id.x];
    float3 currVel = (currPrePos - currPos) / deltaTime;
    
    
    // collision (?here)
    ResolveCollisions(currPrePos, currVel, collisionDamping);
    
    // update velocity and position
    Velocities[id.x] = currVel;
    // PredictedPositions[id.x] = currPrePos;
    Positions[id.x] = currPrePos;       // (?) update position here or after vv apply? 
}

[numthreads(ThreadGroupSize, 1, 1)]
void VorticityAndViscosity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;

    // float3 pos = PredictedPositions[id.x];      
    float3 pos = Positions[id.x];      // [Fixed]: using Positon instead of PredictedPositions
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;

    float3 viscosityForce = float3(0.0f, 0.0f, 0.0f);
    float3 vorticityForce = float3(0.0f, 0.0f, 0.0f);
    float3 velocity = Velocities[id.x];

    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex += 1;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;
            
            // Skip if looking at self
            if (neighbourIndex == id.x) continue;

            // float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 neighbourPos = Positions[neighbourIndex];    // [Fixed]: using Positon instead of PredictedPositions
            float3 dir2Neighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(dir2Neighbour, dir2Neighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;     // need or not? radius check can be in smoothing kernel

            float dst = sqrt(sqrDstToNeighbour);
            float3 neighbourVelocity = Velocities[neighbourIndex];
                // V_ij = V_j - V_i
            float3 V_ij = neighbourVelocity - velocity;
            
            // viscosity
            viscosityForce += V_ij * WPoly6(dir2Neighbour, smoothingRadius);
            
            // vorticity    // to be continue here
            // float3 omega = cross(V_ij, WSpikyGrad(dir2Neighbour, smoothingRadius));
            // vorticityForce = ...;
        }
    }
    // PBF: viscosityStrength set as 0.01 is good
    // Velocities[id.x] += viscosityForce * viscosityStrength;     
    Velocities[id.x] += viscosityForce * viscosityStrength * deltaTime;     
}

// rendering //////////////////////////////////////////////////////


