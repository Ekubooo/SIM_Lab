#pragma kernel InBlockRadix
#include "./RadixHelper.hlsl"

RWStructuredBuffer<uint> Elements;          // input
RWStructuredBuffer<uint> BucketCounter;     // [1024 * 16]  or [GroupNum * BucketNum]
RWStructuredBuffer<uint> GlobalPSum;        // [1024 ^ 2]   or [GroupNum * GroupSize] 

groupshared uint localPrefix[THREAD_NUM_X];

uint g_BlocksNums;  // = 1024
uint currIteration;

// EScan
void PrefixSumLocal(uint IGid : SV_GroupIndex, uint cIndex)
{
    uint d = 0;
    uint i = 0;
    uint offset = 1;
    uint totalNum = THREAD_NUM_X;
    
    // Up sweep
    [unroll]
    for (d = totalNum>>1; d > 0; d >>= 1)
    {
        GroupMemoryBarrierWithGroupSync();
        if (IGid < d)
        {
            uint indexA = offset * (2 * IGid + 1) - 1;
            uint indexB = offset * (2 * IGid + 2) - 1;

            localPrefix[indexB] += localPrefix[indexA];
        }
        offset *= 2;
    }

    // Set 0 part, 0 thread is the last active thread, it's safe to access 
    if (IGid == 0)
    {
        // IScan result output
        BucketCounter[cIndex] = localPrefix[totalNum - 1];
        
        localPrefix[totalNum - 1] = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    // Down sweep
    [unroll]
    for (d = 1; d < totalNum; d *= 2)  
    {
        offset >>= 1;
        GroupMemoryBarrierWithGroupSync();

        if (IGid < d)
        {
            uint indexA = offset * (2 * IGid + 1) - 1;
            uint indexB = offset * (2 * IGid + 2) - 1;

            uint sum = localPrefix[indexA];
            localPrefix[indexA] = localPrefix[indexB];
            localPrefix[indexB] += sum;
        }
    }
    
    GroupMemoryBarrierWithGroupSync();
}


// one thread process one element
// 1024 dispitch, 1024 per group.

[numthreads(THREAD_NUM_X, 1, 1)]
void InBlockRadix(uint GI : SV_GroupIndex, uint3 DTid : SV_DispatchThreadID, uint3 Gid : SV_GroupID)
{
    // get curr digit correspend to 4-bit LSD
    uint digit = get4Bits(Elements[DTid.x], currIteration);
    
    [unroll(RADIX_R)]
    for (uint r = 0; r < RADIX_R; ++r)
    {
        // load to share memory 
        localPrefix[GI] = (digit == r ? 1 : 0);
        GroupMemoryBarrierWithGroupSync();

        // prefix sum according to r in this blocks
        PrefixSumLocal(GI, r * g_BlocksNums + Gid.x);
        
        // now localPrefix[] is EScan of current group.

        // Write back prefix sum according to r
        // access by currBit, so no conflict
        if(digit == r)  GlobalPSum[DTid.x] = localPrefix[GI];
        
        GroupMemoryBarrierWithGroupSync();
    }
}



